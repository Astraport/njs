var net = require('net')
	, fs = require('fs')
	, path = require('path')	
	, request = "<policy-file-request/>"
	, util = require(process.binding('natives').util ? 'util' : 'sys');

process.title = "fxs";

var CrossDomainServer = module.exports = function()
{
	process.EventEmitter.call( this );
	this.contents = "";
	this.buffer = null;	
	//configure default options
	this.options = {
		port: 843,
		host: "127.0.0.1"
	}
}

util.inherits( CrossDomainServer, process.EventEmitter );

CrossDomainServer.prototype.load = function( conf, policy )
{
	var self = this;
	//default config path
	conf = conf != null ? conf : path.join( __dirname, "conf.json" );
	console.log( "fxs: loading configuration %j", conf );
	fs.readFile( conf, function( err, data )
	{
		if( !err && data )
		{
			var contents = data.toString();
			try
			{
				self.options = JSON.parse( contents );
			}catch( err )
			{
				console.log( "fxs: could not parse configruation json" );
				self.emit( "error", err );
				return;
			}
		
			//use the default policy file 
			if( !self.options.policy )
			{
				self.options.policy = path.join( __dirname, "crossdomain.xml" );
			}
			
			//overwrite with the code-specified policy file location
			if( policy != null )
			{
				self.options.policy = policy;
			}
		
			//read in the cross domain file and start listening
			self.start();
		}else if( err )
		{
			console.log( "fxs: could not read configuration %j", conf );
			self.emit( "error", err );
		}
	} );
}

/**
*	Starts the cross domain policy file server.
*/
CrossDomainServer.prototype.start = function()
{
	var self = this;
	console.log( "fxs: reading cross domain policy from %j", this.options.policy );
	fs.readFile( this.options.policy, function( err, data )
	{
		if( err )
		{
			self.emit( "error", err );
			return;
		}

		this.buffer = data;
		this.contents = data.toString();
		console.log( "fxs: loaded cross domain policy file of %j bytes.", this.buffer.length );

		//start watching for changes to the policy file
		self.watch();

		//have to use the globally scoped here
		//to start listening for requests
		self.listen();
	} );
}

CrossDomainServer.prototype.reload = function( err, data )
{
	var self = this;
	fs.readFile( this.options.policy, function( err, data )
	{
		if( err )
		{
			throw err;
		}

		this.buffer = data;
		this.contents = data.toString();
		console.log( "fxs: reloaded %j (%j bytes)", self.options.policy, this.buffer.length );
		self.emit( "reload", contents );
	} );
}

CrossDomainServer.prototype.watch = function()
{
	var self = this;
	
	//configured not to watch the cross domain
	if( this.options.watch === false )
	{
		return;
	}
	
	fs.watchFile( this.options.policy, this.options.monitor || {}, function( curr, prev )
	{
		if( +curr.mtime !== +prev.mtime )
		{
			self.reload();
		}
	});
}

CrossDomainServer.prototype.close = function()
{
	if( this._server )
	{
		try
		{
			this._server.close();
		}catch( err )
		{
			console.log( "fxs: error while closing tcp server" );
			this.emit( "error", err );
		}
	}
}

CrossDomainServer.prototype.listen = function()
{
	var self = this;
	this._server = net.createServer( function( socket ) {
		socket.ondata = function( d, start, end )
		{
			var message = d.toString('utf8', start, end);
			
			if( message === request )
			{
				console.log( "fxs: serving policy file of %j bytes to %j", buffer.length, socket.remoteAddress );
				socket.write( contents );
				socket.end( "\0" );
			}else{
				console.log( "fxs: echo response: %j", message );
				//not a policy file request, act as an echo server
				socket.write( message );
			}
		}
	})
	console.log( "fxs: starting server on %j:%j", this.options.host, this.options.port );
	try
	{
		this._server.listen( this.options.port, this.options.host );
		this.connected = true;
		this.emit( "connected", this.options.port, this.options.host );
		console.log( "fxs: cross domain server started on port %j, accepting policy file requests", this.options.port );
	}catch( err )
	{
		this.emit( "error", err );
		return;
	}
	
	this._server.on( "close", function()
	{
		self.connected = false;
		self.emit( "closed", self );
	} );

	//effective uid handling
	if( process.getuid() === 0 )
	{	
		if( !this.options.euid )
		{
			console.log( "fxs: running as root but no effective uid configured" );
			process.exit( -1 );
		}
		
		try
		{
			console.log( "fxs: attempting to switch to user %j", this.options.euid );
			process.setuid( this.options.euid );
			console.log( "fxs: running with uid %j", process.getuid() );
		}catch( err )
		{
			console.log( "fxs: could not switch to effective uid %j", this.options.euid );
			this.emit( "error", err );
			process.exit( -1 );
		}
	}
}